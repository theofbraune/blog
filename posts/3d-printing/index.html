<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Make it Stand - Balancing Shapes for 3D-printing</title>
<link rel=stylesheet href=../../css/bootstrap.min.css><link rel=stylesheet href=../../css/home.css><link rel=stylesheet href=../../css/style_landing.css><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><link rel=icon href=../../images/integral_icon.png></head><body><header id=site-header><nav><div class=logo><a href=#>Theo Braune</a></div><ul class=nav-links><li><a href=../../index.html>Home</a></li><li><a href=../posts/index.html>Posts</a></li><li><a href=../custum/projects/index.html>Projects</a></li></ul><div class=hamburger-menu><div class=bar></div><div class=bar></div><div class=bar></div></div></nav></header><main class=site-main><div class=container><article class=single-post><h1 class="entry-title mt-4 mb-4">Make it Stand - Balancing Shapes for 3D-printing</h1><div class="post-meta mb-2"><span class=post-author>Posted by: Theo and Jingyi
</span><span class=post-date><time>Mar 22, 2022, 6:00PM</time>
</span><span class=post-tags><a href=https://theofbraune.github.io/blog/tags/programming/>Programming</a>
<a href=https://theofbraune.github.io/blog/tags/projects/>Projects</a>
<a href=https://theofbraune.github.io/blog/tags/fabrication/>Fabrication</a></span></div><div class=entry-content><p>Through the evolution of 3D-printers, the it has become more and more easy to produce prototypes of 3 dimensional shapes. In this project we developed our first software to produce shapes and printable objects for a 3D-printer.
This project was part as a final project of the Ã‰cole Polytechnique course &ldquo;X-INF 573 Digital Representations and Analysis of Shapes&rdquo;.</p><p>The aim of this project was to give an input shape, define an angle an orientation axis and then to carve out and deform the shape, such that the new modified shape can stand in this desired position.</p><table><thead><tr><th style=text-align:center><figure><img src=../../images/3dprinting/initial_problem.png width=40% height=40%></figure></th></tr></thead><tbody><tr><td style=text-align:center>We want to have a rocket in a tilted position, that can stand stablely.</td></tr></tbody></table><p>The scientific foundation for this project can be found in <a href=https://igl.ethz.ch/projects/make-it-stand/>Prevost et al.</a> We were both not part of the work, we just tried to reproduce their idea and to gain experience with 3d-printing soft- and hardware.</p><table><thead><tr><th style=text-align:center><figure><img src=../../images/3dprinting/problem_stat.png width=30% height=30%></figure></th></tr></thead><tbody><tr><td style=text-align:center>Further examples of shapes in tilted positions.</td></tr></tbody></table><p>In this post we will first describe the rough roadmap and afterwards we will get into detail how we implemented all this precisely.</p><h2 id=roadmap>Roadmap</h2><p>In the first part of the project we focused to get a discrete voxelized representation of our three dimensional shapes.</p><table><thead><tr><th style=text-align:center><figure><img src=../../images/3dprinting/voxelization.png width=30% height=30%></figure></th></tr></thead><tbody><tr><td style=text-align:center>Voxelization of three dimensional shapes.</td></tr></tbody></table><p>Note that we assume, that the tilting already took place before the creation of the <code>.obj</code> file.
This can be done for example with Houdini SideFx Software, later we will discuss how this can be done precisely.</p><p>Once we have this boolean volumetric representation of the (tilted) shape, we determine a support base on which the object should be able to stand on without falling.</p><table><thead><tr><th style=text-align:center><figure><img src=../../images/3dprinting/before_carving.png width=30% height=30%></figure></th></tr></thead><tbody><tr><td style=text-align:center>Support base of the rocket with indicated boundary voxels.</td></tr></tbody></table><p>Further we determine which voxels belong to the boundary and which are part of the inner of the shape as seen in the upper image. Next we determine the center of mass and check, in which way the center of mass is away from the from the support base. Once this is determined, we start to carve the inner vertices until either the center of mass is inside the support base and the shape can stand stablely.</p><table><thead><tr><th style=text-align:center><figure><img src=../../images/3dprinting/after_carving.png width=30% height=30%></figure></th></tr></thead><tbody><tr><td style=text-align:center>Center of mass inside the support base :).</td></tr></tbody></table><p>In this case we are done and we can start to print the shape. It might happen, that we carve layer by layer through the shape and pass the support base, but the center of mass does not end up in the support base. In this case carving alone is not sufficient. If the object is for example very tall and thin, it also makes intuitively sense, that if the shape is tilted heavily in one direction, carving alone might not be sufficient.</p><figure><img src=../../images/3dprinting/rocket_without_booster.PNG width=15% height=15%></figure><p>In order to overcome this issue, we came up with two options. The first one is -if it is possible- to add further mass to stabelize the figure, such that the center of mass becomes moved by that amd the carving can be more efficient.<figure><img src=../../images/3dprinting/add_mass.png width=70% height=70%></figure></p><p>The second option is to deform the shape, such that the features of the shape are preserved, but at the same time the mass distribution becomes improved.<figure><img src=../../images/3dprinting/deformation.png width=70% height=70%></figure></p><p>In the initial <a href=https://igl.ethz.ch/projects/make-it-stand/>paper mentioned above</a> they suggested an alternating algorithm between deforming and carving in order to improve the weight distribution of the shape.</p><h2 id=implementation>Implementation</h2><p>Well, so far these rough ideas might not seem that difficult, but then you get to the point, where you just want to take the mesh and get a stable <code>.stl</code> file, it is a bit challenging.</p><p>We made use of Houdini Software for the purposes, because a lot of the file type conversion, mesh smoothing or cage deformations can be done there quite easily.
In order to create an <code>.obj</code> file of a shape, that is tilted, we first start to import an <code>.obj</code> of the shape with a file node in Houdini and remesh it.</p><p><figure><img src=../../images/3dprinting/remeshing_in_houdini.png width=50% height=50%></figure>In the next step we use a deform handle to bring the bunny in the desired tilted position.<figure><img src=../../images/3dprinting/deform_the_shape.png width=50% height=50%></figure>In order to tilt and move the shape with the mouse, one needs to click on the geometry handle in the left bar. Next, to create the support base where the shape should stand on, we will delete all nodes that have a y-component below zero and fill them. In order to do this, we create a boolean attribute with the information, whether a node is to delete.</p><figure><img src=../../images/3dprinting/coloring_pts_to_delete.png width=50% height=50%></figure><p>In the code of the pointwrangle <code>mark_to_delete</code> add the code</p><pre tabindex=0><code class=language-code data-lang=code>
if(v@P.y&lt;0){
    i@to_delete=1;
}
</code></pre><p>Now use a blast node to delete the blue vertices<figure><img src=../../images/3dprinting/delete_selection.png width=50% height=50%></figure></p><p>To fill this hole, we use a polyfill node. But before we can do that, we need to declare which hole it should fill. To do this, we need to declare a boundary first.</p><p><figure><img src=../../images/3dprinting/boundary_edge_bunny.PNG width=50% height=50%></figure>With this boundary, we can then fill the hole with a polyfill node, where we will need to remesh afterwards, since it creates an anisotropic mesh, which is not good for our purpose.<figure><img src=../../images/3dprinting/fill_the_hole.PNG width=50% height=50%></figure>In the end, to export the tilted mesh with stable base we can again use a file node<figure><img src=../../images/3dprinting/remeshing_the_damage.PNG width=50% height=50%></figure>but I highly recommend to deactivate that node during most of the time, because as soon as there is some change to the mesh, it will directly overwrite the change to the disk. This not just slows down your program, often you don&rsquo;t even want that.</p><p>Once we have the tilted inital mesh, we can start with the voxelization process.</p><h3 id=voxelization>Voxelization</h3><p>For that we made use of the <a href=http://www.open3d.org/>Open3d</a> and followed their tutorial to convert a triangulated mesh into a voxelized surface, more precisely the code we used can be found <a href=http://www.open3d.org/docs/release/tutorial/geometry/voxelization.html>here</a>. Their code cell [5] was of great use for our purpose, because it turns the mesh into a dense voxelized grid together with a voxelized surface.
Our code then becomes first:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> open3d <span style=color:#66d9ef>as</span> o3d
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pdb
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> json
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pdb
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> copy
</span></span><span style=display:flex><span><span style=color:#75715e>#from scipy.sparse import csr_matrix</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> carve_voxel <span style=color:#f92672>import</span> voxel_carving
</span></span><span style=display:flex><span>[<span style=color:#f92672>...</span>]
</span></span><span style=display:flex><span>name<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bunny_final&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#name = &#34;bunny_flipped_3&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#name= &#34;rocket_turning_flipped_2&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mesh_path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;./data/&#34;</span><span style=color:#f92672>+</span>name<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;.obj&#34;</span>
</span></span><span style=display:flex><span>mesh <span style=color:#f92672>=</span> o3d<span style=color:#f92672>.</span>io<span style=color:#f92672>.</span>read_triangle_mesh(mesh_path)
</span></span><span style=display:flex><span>output_voxel_filename <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>abspath(<span style=color:#e6db74>&#34;./data/&#34;</span><span style=color:#f92672>+</span>name<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;_voxelized.obj&#34;</span>)
</span></span><span style=display:flex><span>output_mesh_filename <span style=color:#f92672>=</span>os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>abspath(<span style=color:#e6db74>&#34;./data/&#34;</span><span style=color:#f92672>+</span>name<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;_scaled.obj&#34;</span>)
</span></span><span style=display:flex><span>camera_path <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>abspath(<span style=color:#e6db74>&#34;./data/sphere.ply&#34;</span>)
</span></span><span style=display:flex><span>np_file <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;./data/&#34;</span><span style=color:#f92672>+</span>name<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;_voxel&#34;</span>
</span></span><span style=display:flex><span>json_filename <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;./data/&#34;</span><span style=color:#f92672>+</span>name<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;_voxel.json&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>visualization <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>cubic_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.56</span> <span style=color:#75715e># 128 * 0.04</span>
</span></span><span style=display:flex><span>voxel_resolution <span style=color:#f92672>=</span> <span style=color:#ae81ff>256.0</span> <span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>mesh_scale <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.0</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;surface mesh&#34;</span>)
</span></span><span style=display:flex><span>print(mesh)
</span></span><span style=display:flex><span>o3d<span style=color:#f92672>.</span>visualization<span style=color:#f92672>.</span>draw_geometries([mesh])
</span></span><span style=display:flex><span>mesh, voxel_grid, voxel_carving, voxel_surface <span style=color:#f92672>=</span> voxel_carving(mesh, output_voxel_filename, camera_path, cubic_size, voxel_resolution)
</span></span><span style=display:flex><span><span style=color:#75715e># We can directly zoom out mesh a little bit </span>
</span></span><span style=display:flex><span><span style=color:#75715e># to make sure that the voxel is inside</span>
</span></span><span style=display:flex><span>mesh<span style=color:#f92672>.</span>scale(mesh_scale, center<span style=color:#f92672>=</span>mesh<span style=color:#f92672>.</span>get_center())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>o3d<span style=color:#f92672>.</span>io<span style=color:#f92672>.</span>write_voxel_grid(output_voxel_filename,voxel_grid)
</span></span><span style=display:flex><span>o3d<span style=color:#f92672>.</span>io<span style=color:#f92672>.</span>write_triangle_mesh(output_mesh_filename, mesh)
</span></span></code></pre></div><p>In this example in the line <code>from carve_voxel import voxel_carving</code>, the module <code>carve_voxel</code> is mainly the mentioned code block [5] from the Open3D tutorial. Note that the parameter <code>voxel_resolution</code> will be cubed! Therefore one needs to be careful with this parameter. In our tests a parameter of 256 was at the upper maximum of what we could compute in a reasonable time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>N_index <span style=color:#f92672>=</span> int(voxel_resolution)
</span></span><span style=display:flex><span>voxel_matrix <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((N_index,N_index,N_index))
</span></span><span style=display:flex><span>voxel_matrix <span style=color:#f92672>=</span> voxel_to_numpy(voxel_grid, voxel_resolution <span style=color:#f92672>=</span> N_index)
</span></span></code></pre></div><p>Here we create a numpy array with the size &ldquo;N_index x N_index x N_index&rdquo;, where we will save the boolean information whether a grid cell is included in the voxelized shape.</p><p>In this case the function <code>voxel_to_numpy(...)</code> is given by</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>voxel_to_numpy</span>(voxels, voxel_resolution <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Input: An instance if the open3d voxelgrid datastructure, the number of voxels per sidelength (voxel_resolution)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Output: A numpy array of voxel_resolution x voxel_resolution x voxel_resolution with 1 and 0, where ever we have a voxel or not 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    vx_numpy <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((voxel_resolution,voxel_resolution,voxel_resolution))
</span></span><span style=display:flex><span>    grid <span style=color:#f92672>=</span> voxels<span style=color:#f92672>.</span>get_voxels()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> grid: <span style=color:#75715e># index is from 1 to scale/size</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#print(i.grid_index)</span>
</span></span><span style=display:flex><span>        voxel_index <span style=color:#f92672>=</span> i<span style=color:#f92672>.</span>grid_index <span style=color:#75715e>#a[0] a[1] a[2]</span>
</span></span><span style=display:flex><span>        vx_numpy[voxel_index[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,voxel_index[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,voxel_index[<span style=color:#ae81ff>2</span>]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> vx_numpy
</span></span></code></pre></div><p>I am not very proud about this implementation, it seems a bit dump and it is not very quick, but it is efficient.
Lastly, to finalize the file <code>voxelizer.py</code>, we need to add the lines,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>inside, surface <span style=color:#f92672>=</span> voxel_carv_preprocess_numpy(voxel_matrix, thickness<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>np<span style=color:#f92672>.</span>save(file<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;./data/&#34;</span><span style=color:#f92672>+</span>name<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;_voxel_surface&#34;</span>,arr<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>array(surface, dtype<span style=color:#f92672>=</span>bool))
</span></span><span style=display:flex><span>np<span style=color:#f92672>.</span>save(file<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;./data/&#34;</span><span style=color:#f92672>+</span>name<span style=color:#f92672>+</span><span style=color:#e6db74>&#34;_voxel_int&#34;</span>,arr<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>array(inside, dtype<span style=color:#f92672>=</span>bool))
</span></span></code></pre></div><p>where we basically seperate the inner voxels from the surface and can prescribe the thickness of the boundary. We save them as numpy arrays, because with the special naming of the files the <code>carving.py</code> file will be able to read them out directly.</p><h3 id=carving>Carving</h3><p>If we named the files correctly, the first lines of our carving program will be to load the numpy arrays, that have been created in the voxelization program, i.e</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#name= &#39;rocket_flipped&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#name=&#39;rocket_turning_flipped_2&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#name = &#34;bunny_flipped_3&#34;</span>
</span></span><span style=display:flex><span>name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;bunny_final&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>voxel_surface <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>load(<span style=color:#e6db74>&#39;data/&#39;</span><span style=color:#f92672>+</span>name<span style=color:#f92672>+</span><span style=color:#e6db74>&#39;_voxel_surface.npy&#39;</span>)
</span></span><span style=display:flex><span>voxel_inside <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>load(<span style=color:#e6db74>&#39;data/&#39;</span><span style=color:#f92672>+</span>name<span style=color:#f92672>+</span><span style=color:#e6db74>&#39;_voxel_int.npy&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>voxels <span style=color:#f92672>=</span> voxel_inside <span style=color:#f92672>+</span> voxel_surface
</span></span></code></pre></div><p>The first part of the carving will be to determine, where we will have our support base for the carving, i.e a rectangle of voxels, where the center of mass should end up. We start to search from the bottom to the top to the first layer in y-direction, where we have a voxel. Then we go one layer above, because it turned out that difficulties in the termination of the algorithm can occur, when we take directly the first layer. Next we look for the largest rectangle contained in this layer. This will be our support base. As a code, this function has the following form</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>support_base</span>(voxels_np):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Input: A numpy array (full) with the information whether the voxel is contained
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Output: the range of support bsae
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    NOTE: The y axis is perpendicular to the support base. 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          The support base is close to y=0
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    grid_shape <span style=color:#f92672>=</span> voxels_np<span style=color:#f92672>.</span>shape
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> id_y <span style=color:#f92672>in</span> range(grid_shape[<span style=color:#ae81ff>1</span>]):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(np<span style=color:#f92672>.</span>count_nonzero(voxels_np[:,id_y,:]<span style=color:#f92672>==</span><span style=color:#66d9ef>True</span>)<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>):
</span></span><span style=display:flex><span>            <span style=color:#75715e>#id_y+=1 #NOTE: After visualization, second floor is connected</span>
</span></span><span style=display:flex><span>            support_base <span style=color:#f92672>=</span> voxels_np[:,id_y,:]
</span></span><span style=display:flex><span>            support_index <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>nonzero(support_base)
</span></span><span style=display:flex><span>            <span style=color:#75715e>#pdb.set_trace()</span>
</span></span><span style=display:flex><span>            max_x <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>max(support_index[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>            min_x <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>min(support_index[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>            max_z <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>max(support_index[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            min_z <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>min(support_index[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            center <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([int((max_x<span style=color:#f92672>+</span>min_x)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>), int((min_z<span style=color:#f92672>+</span>max_z)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)])
</span></span><span style=display:flex><span>            scaled_support_base <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>full((grid_shape[<span style=color:#ae81ff>0</span>],grid_shape[<span style=color:#ae81ff>2</span>]),<span style=color:#66d9ef>False</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>#Here we manually set the size for the support base</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>#This is chosen purely from intuition and it is possible that there are better choices.</span>
</span></span><span style=display:flex><span>            scaled_support_base[center[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>:center[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,center[<span style=color:#ae81ff>1</span>]:center[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>((np<span style=color:#f92672>.</span>logical_and(scaled_support_base,support_base)<span style=color:#f92672>==</span>scaled_support_base)<span style=color:#f92672>.</span>all()):
</span></span><span style=display:flex><span>                print(<span style=color:#e6db74>&#34;Support base is reasonable!!&#34;</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> scaled_support_base
</span></span></code></pre></div><p>Then the support base can be of the form<figure><img src=../../images/3dprinting/before_carving.png width=30% height=30%></figure></p><p>To compute the center of mass, we just compute the mean of all x-,y- and z-components, i.e</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>center_of_mass</span>(voxels_np):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Input: A numpy array (full) with the information whether the voxel is contained
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Output: The grid coordinates of the center of mass
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    grid_shape <span style=color:#f92672>=</span> voxels_np<span style=color:#f92672>.</span>shape
</span></span><span style=display:flex><span>    counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    center <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array([<span style=color:#ae81ff>0.</span>,<span style=color:#ae81ff>0.</span>,<span style=color:#ae81ff>0.</span>])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> id_x <span style=color:#f92672>in</span> range(grid_shape[<span style=color:#ae81ff>0</span>]):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> id_y <span style=color:#f92672>in</span> range(grid_shape[<span style=color:#ae81ff>1</span>]):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> id_z <span style=color:#f92672>in</span> range(grid_shape[<span style=color:#ae81ff>2</span>]):
</span></span><span style=display:flex><span>                <span style=color:#75715e>#check whether we hit a a voxel in the mesh</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(voxels_np[id_x,id_y,id_z]<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>                    counter<span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                    center <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>/</span>float(counter))<span style=color:#f92672>*</span>np<span style=color:#f92672>.</span>array([float(id_x),float(id_y),float(id_z)]) <span style=color:#f92672>+</span> (float(counter<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>/</span>float(counter))<span style=color:#f92672>*</span>center
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>([int(center[<span style=color:#ae81ff>0</span>]),int(center[<span style=color:#ae81ff>1</span>]),int(center[<span style=color:#ae81ff>2</span>])]) 
</span></span></code></pre></div><p>If these are calculated, we can start with the carving process.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>carving</span>(voxel_surface,voxel_inside,support_base):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    grid_shape <span style=color:#f92672>=</span> voxel_surface<span style=color:#f92672>.</span>shape
</span></span><span style=display:flex><span>    carved_voxel_inside <span style=color:#f92672>=</span> voxel_inside
</span></span><span style=display:flex><span>    support_index <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>nonzero(support_base)
</span></span><span style=display:flex><span>    max_x <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>max(support_index[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    min_x <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>min(support_index[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    max_z <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>max(support_index[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>    min_z <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>min(support_index[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>    com <span style=color:#f92672>=</span> center_of_mass(voxel_surface<span style=color:#f92672>+</span>voxel_inside) 
</span></span><span style=display:flex><span>    com_x <span style=color:#f92672>=</span> com[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    com_z <span style=color:#f92672>=</span> com[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(com_x<span style=color:#f92672>&gt;=</span>min_x <span style=color:#f92672>and</span> com_x<span style=color:#f92672>&lt;=</span>max_x <span style=color:#f92672>and</span> com_z<span style=color:#f92672>&gt;=</span>min_z <span style=color:#f92672>and</span> com_z<span style=color:#f92672>&lt;=</span>max_z):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> carved_voxel_inside
</span></span><span style=display:flex><span>    <span style=color:#75715e># to move com_x, cut y-z plane</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># to move com_z, cut y-x plane</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(com_x<span style=color:#f92672>&lt;</span>min_x): 
</span></span><span style=display:flex><span>        [<span style=color:#f92672>...</span>]
</span></span></code></pre></div><p>We check if the center of mass is already in the desired area, if not, we check where we need to take away mass in order to move the center of mass inside the support base.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>carving</span>(voxel_surface,voxel_inside,support_base):
</span></span><span style=display:flex><span>    [<span style=color:#f92672>...</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(com_x<span style=color:#f92672>&lt;</span>min_x): <span style=color:#75715e>#cut y-z plane</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#pdb.set_trace()</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(grid_shape[<span style=color:#ae81ff>0</span>]):
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(carved_voxel_inside[i,:,:]<span style=color:#f92672>.</span>any()<span style=color:#f92672>==</span><span style=color:#66d9ef>False</span>):
</span></span><span style=display:flex><span>                print(<span style=color:#e6db74>&#34;for x, skip &#34;</span>,i)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                cut_x <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>                print(<span style=color:#e6db74>&#39;entered&#39;</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(com_x<span style=color:#f92672>&lt;</span>min_x <span style=color:#f92672>and</span> cut_x<span style=color:#f92672>&lt;</span>grid_shape[<span style=color:#ae81ff>0</span>]):
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>&#34;com_x=&#34;</span>,com_x)
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>&#34;min_x=&#34;</span>,min_x)
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>&#34;cut_x=&#34;</span>,cut_x)
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>&#34;com_z=&#34;</span>,com_z)
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>&#34;================&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>((min_x<span style=color:#f92672>-</span>com_x<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>) ):
</span></span><span style=display:flex><span>                carved_voxel_inside[cut_x:cut_x<span style=color:#f92672>+</span><span style=color:#ae81ff>5</span>,:,:]<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>                cut_x<span style=color:#f92672>+=</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                carved_voxel_inside[cut_x,:,:]<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>                cut_x<span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            com <span style=color:#f92672>=</span> center_of_mass(voxel_surface<span style=color:#f92672>+</span>carved_voxel_inside) 
</span></span><span style=display:flex><span>            com_x <span style=color:#f92672>=</span> com[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>            com_z <span style=color:#f92672>=</span> com[<span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    [<span style=color:#f92672>...</span>]
</span></span></code></pre></div><p>We basically search for the first layer, that we can remove. If we are far enough away from the support base with the leading carving layer and the center of mass, we cut away several layers at once. After each carving step we recalculate the center of mass of the carved shape and verify if the center of mass is in the support base now.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>carving</span>(voxel_surface,voxel_inside,support_base):
</span></span><span style=display:flex><span>    [<span style=color:#f92672>...</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(com_x<span style=color:#f92672>&lt;</span>min_x):
</span></span><span style=display:flex><span>        [<span style=color:#f92672>...</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(com_x<span style=color:#f92672>&gt;</span>max_x):
</span></span><span style=display:flex><span>        [<span style=color:#f92672>...</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(com_z<span style=color:#f92672>&lt;</span>min_z): <span style=color:#75715e>#cut y-x plane</span>
</span></span><span style=display:flex><span>        [<span style=color:#f92672>...</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(com_z<span style=color:#f92672>&gt;</span>max_z):
</span></span><span style=display:flex><span>        [<span style=color:#f92672>...</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (com_x <span style=color:#f92672>&gt;=</span>min_x <span style=color:#f92672>and</span> com_x <span style=color:#f92672>&lt;=</span>max_x <span style=color:#f92672>and</span> com_z <span style=color:#f92672>&gt;=</span>min_z <span style=color:#f92672>and</span> com_z <span style=color:#f92672>&lt;=</span>max_z):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Carving is successful! The new center of mass is in the support base!&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> carved_voxel_inside
</span></span></code></pre></div><p>If the algorithm does not terminate, carving is not sufficient! In this case one either needs to add mass and repeat the carving process.
The other option is to deform the shape. In the original paper, they deformed the carved shape. In our attempt, we had some struggle to retransform the carved boolean shape in an inner and outer mesh in an <code>.obj</code> format. Our solution is therefore a semi automatic approach. We print out the values of the current carving plane and the center of mass. If the carving fails, one can deduce where we need to add more mass and how we need to deform them. Prevost et al used an energy from the bounded biharmonic weights with deformation handles in order to achieve the deformation. In our approach we use a cage based deformation in Houdini to deform the shapes. It should be noted, that this needs to be done before the carving process, we were not able yet to implement an alternating carving and deforming.</p><h3 id=deformation-with-houdini>Deformation with Houdini</h3><p>In order to implement a cage based deformation in Houdini, we need to define a bounding box first<figure><img src=../../images/3dprinting/bounding_box_cage.PNG width=50% height=50%></figure>For our purpose, we used a 3x3x3 bounding box, but this can be modified in the parameters of the node.
To apply the cage based deformation to an object, one needs to use an edit node, which will allow to deform the cage. The lattice node will allow to deform the shape according to the cage deformation.<figure><img src=../../images/3dprinting/initial_bunny.PNG width=50% height=50%></figure>The first input to the Lattice node needs to be the shape in question. The second input is the initial cage, then third one is the deformed cage. The output of this node will be the shaped deformed according to the rules of the edit nodes.</p><p>To use an edit node, one needs to select first a number of points inside the cage.<figure><img src=../../images/3dprinting/select_group.PNG width=30% height=30%></figure><figure><img src=../../images/3dprinting/select_nodes.PNG width=30% height=30%></figure></p><p>Once these nodes are selected, the selection of nodes can be moved around.</p><p><figure><img src=../../images/3dprinting/deformed_cage.PNG width=30% height=30%></figure>.</p><p>If the transformation is applied, and we merge them together properly, the result could look like that:<figure><img src=../../images/3dprinting/deformed_bunny.PNG width=50% height=50%></figure></p><p>If you do this a few times, you will notice in which way it is benefitial to deform the shape, before starting the carving.</p><h3 id=stl-files-and-printing>STL-Files and printing</h3><p>If the carving was successful you still cannot print it, because for the 3D-printing, you need a file in a <code>.stl</code> format. That means basically, that you save the shape layer by layer. Fortunately there is a Python module called <a href=https://cdbrauer.github.io/VoxelFuse/><code>voxelfuse</code></a> to do that. The code to export the numpy array into a <code>.stl</code> file is then given by</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> voxelfuse.voxel_model <span style=color:#f92672>import</span> VoxelModel
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> voxelfuse.mesh <span style=color:#f92672>import</span> Mesh
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> voxelfuse.primitives <span style=color:#f92672>import</span> generateMaterials
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    voxel_numpy <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>load(<span style=color:#e6db74>&#39;data/bunny_final_voxel_entire_carved.npy&#39;</span>)
</span></span><span style=display:flex><span>    model <span style=color:#f92672>=</span> VoxelModel(voxel_numpy, generateMaterials(<span style=color:#ae81ff>4</span>))
</span></span><span style=display:flex><span>    mesh <span style=color:#f92672>=</span> Mesh<span style=color:#f92672>.</span>fromVoxelModel(model)
</span></span><span style=display:flex><span>    mesh<span style=color:#f92672>.</span>export(<span style=color:#e6db74>&#39;bunny_final_scaled_carved.stl&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p>Now, if everything went well, you should have a printable file now.
Thanks to the TÃ©lÃ©com Paris Fablab we were able to print our shapes with their 3D-Printer. We used a Creality3D CR-10S Pro Imprimante 3D to start printing our models.
Before starting the printing process, we use the <code>Ultimaker Cura</code> Software to prepare our 3D prints.</p><p>Make sure, that you increase in the printer settings the infill to 100%, since we want to use the mass of the infill for the balancing.</p><figure><img src=../../images/3dprinting/3d_printing_infill.png width=50% height=50%></figure><p>The Ultimaker software then creates &ldquo;a roadmap&rdquo; for the 3D-printer at what time it should travel with the nozzle to which position with which speed, also to create the support.</p><figure><img src=../../images/3dprinting/layer_by_layer.png width=50% height=50%></figure><p>This plan can then be saved to disk and excecuted by the 3D-printer.</p><figure><img src=../../images/3dprinting/printer_moving.gif width=50% height=50%></figure><p>The successful models can be seen here for example<figure><img src=../../images/3dprinting/pinecone_falling.gif width=50% height=50%></figure></p><p>Nevertheless, one needs to be careful with the thickness and position of the boundary. If the boundary is too thin and has no support behind it, the surface easily breaks.<figure><img src=../../images/3dprinting/shell_broken.png width=40% height=40%></figure></p><p>Nevertheless, you can still get your tilted christmas tree pinecone :)</p><figure><img src=../../images/3dprinting/christmas_tree.gif width=40% height=40%></figure><p>The code for this project can be found under <a href=https://github.com/JeansLli/X-INF574_3D-printing>https://github.com/JeansLli/X-INF574_3D-printing</a></p></div></article></div></main><footer id=site-footer class="bg-dark text-white pb-4 pt-4"><div class=container><div class="copyright text-center">&copy;2024Theo Braune</div></div></footer><script src=../../js/bootstrap.min.js></script></body></html>